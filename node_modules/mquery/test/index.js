'use strict';

const mquery = require('../');
const assert = require('assert');

describe('mquery', function() {
  let col;

  before(function(done) {
    // get the env specific collection interface
    require('./env').getCollection(function(err, collection) {
      assert.ifError(err);
      col = collection;
      done();
    });
  });

  after(function(done) {
    require('./env').dropCollection(done);
  });

  describe('mquery', function() {
    it('is a function', function() {
      assert.equal('function', typeof mquery);
    });
    it('creates instances with the `new` keyword', function() {
      assert.ok(mquery() instanceof mquery);
    });
    describe('defaults', function() {
      it('are set', function() {
        const m = mquery();
        assert.strictEqual(undefined, m.op);
        assert.deepEqual({}, m.options);
      });
    });
    describe('criteria', function() {
      it('if collection-like is used as collection', function() {
        const m = mquery(col);
        assert.equal(col, m._collection.collection);
      });
      it('non-collection-like is used as criteria', function() {
        const m = mquery({ works: true });
        assert.ok(!m._collection);
        assert.deepEqual({ works: true }, m._conditions);
      });
    });
    describe('options', function() {
      it('are merged when passed', function() {
        let m;
        m = mquery(col, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
        m = mquery({ name: 'mquery' }, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
      });
    });
  });

  describe('toConstructor', function() {
    it('creates subclasses of mquery', function() {
      const opts = { safe: { w: 'majority' }, readPreference: 'p' };
      const match = { name: 'test', count: { $gt: 101 } };
      const select = { name: 1, count: 0 };
      const update = { $set: { x: true } };
      const path = 'street';

      const q = mquery().setOptions(opts);
      q.where(match);
      q.select(select);
      q.updateOne(update);
      q.where(path);
      q.find();

      const M = q.toConstructor();
      const m = M();

      assert.ok(m instanceof mquery);
      assert.deepEqual(opts, m.options);
      assert.deepEqual(match, m._conditions);
      assert.deepEqual(select, m._fields);
      assert.deepEqual(update, m._update);
      assert.equal(path, m._path);
      assert.equal('find', m.op);
    });
  });

  describe('setOptions', function() {
    it('calls associated methods', function() {
      const m = mquery();
      assert.equal(m._collection, null);
      m.setOptions({ collection: col });
      assert.equal(m._collection.collection, col);
    });
    it('directly sets option when no method exists', function() {
      const m = mquery();
      assert.equal(m.options.woot, null);
      m.setOptions({ woot: 'yay' });
      assert.equal(m.options.woot, 'yay');
    });
    it('is chainable', function() {
      const m = mquery();
      let n;

      n = m.setOptions();
      assert.equal(m, n);
      n = m.setOptions({ x: 1 });
      assert.equal(m, n);
    });
  });

  describe('collection', function() {
    it('sets the _collection', function() {
      const m = mquery();
      m.collection(col);
      assert.equal(m._collection.collection, col);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.collection(col);
      assert.equal(m, n);
    });
  });

  describe('$where', function() {
    it('sets the $where condition', function() {
      const m = mquery();
      function go() {}
      m.$where(go);
      assert.ok(go === m._conditions.$where);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.$where('x');
      assert.equal(m, n);
    });
  });

  describe('where', function() {
    it('without arguments', function() {
      const m = mquery();
      m.where();
      assert.deepEqual({}, m._conditions);
    });
    it('with non-string/object argument', function() {
      const m = mquery();

      assert.throws(function() {
        m.where([]);
      }, /path must be a string or object/);
    });
    describe('with one argument', function() {
      it('that is an object', function() {
        const m = mquery();
        m.where({ name: 'flawed' });
        assert.strictEqual(m._conditions.name, 'flawed');
      });
      it('that is a query', function() {
        const m = mquery({ name: 'first' });
        const n = mquery({ name: 'changed' });
        m.where(n);
        assert.strictEqual(m._conditions.name, 'changed');
      });
      it('that is a string', function() {
        const m = mquery();
        m.where('name');
        assert.equal('name', m._path);
        assert.strictEqual(m._conditions.name, undefined);
      });
    });
    it('with two arguments', function() {
      const m = mquery();
      m.where('name', 'The Great Pumpkin');
      assert.equal('name', m._path);
      assert.strictEqual(m._conditions.name, 'The Great Pumpkin');
    });
    it('is chainable', function() {
      const m = mquery();

      let n = m.where('x', 'y');
      assert.equal(m, n);
      n = m.where();
      assert.equal(m, n);
    });
  });
  describe('equals', function() {
    it('must be called after where()', function() {
      const m = mquery();
      assert.throws(function() {
        m.equals();
      }, /must be used after where/);
    });
    it('sets value of path set with where()', function() {
      const m = mquery();
      m.where('age').equals(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.where('x').equals(3);
      assert.equal(m, n);
    });
  });
  describe('eq', function() {
    it('is alias of equals', function() {
      const m = mquery();
      m.where('age').eq(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
  });
  describe('or', function() {
    it('pushes onto the internal $or condition', function() {
      const m = mquery();
      m.or({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$or);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.or(arg);
      assert.deepEqual(arg, m._conditions.$or);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.or(arg);
      m.or({ y: 1 });
      m.or([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$or);
    });
    it('is chainable', function() {
      const m = mquery();
      m.or({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $or: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('nor', function() {
    it('pushes onto the internal $nor condition', function() {
      const m = mquery();
      m.nor({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$nor);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.nor(arg);
      assert.deepEqual(arg, m._conditions.$nor);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.nor(arg);
      m.nor({ y: 1 });
      m.nor([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$nor);
    });
    it('is chainable', function() {
      const m = mquery();
      m.nor({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $nor: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('and', function() {
    it('pushes onto the internal $and condition', function() {
      const m = mquery();
      m.and({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$and);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.and(arg);
      assert.deepEqual(arg, m._conditions.$and);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.and(arg);
      m.and({ y: 1 });
      m.and([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$and);
    });
    it('is chainable', function() {
      const m = mquery();
      m.and({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $and: [{ o: 'k' }] }, m._conditions);
    });
  });

  function generalCondition(type) {
    return function() {
      it('accepts 2 args', function() {
        const m = mquery()[type]('count', 3);
        const check = {};
        check['$' + type] = 3;
        assert.deepEqual(m._conditions.count, check);
      });
      it('uses previously set `where` path if 1 arg passed', function() {
        const m = mquery().where('count')[type](3);
        const check = {};
        check['$' + type] = 3;
        assert.deepEqual(m._conditions.count, check);
      });
      it('throws if 1 arg was passed but no previous `where` was used', function() {
        assert.throws(function() {
          mquery()[type](3);
        }, /must be used after where/);
      });
      it('is chainable', function() {
        const m = mquery().where('count')[type](3).where('x', 8);
        const check = { x: 8, count: {} };
        check.count['$' + type] = 3;
        assert.deepEqual(m._conditions, check);
      });
      it('overwrites previous value', function() {
        const m = mquery().where('count')[type](3)[type](8);
        const check = {};
        check['$' + type] = 8;
        assert.deepEqual(m._conditions.count, check);
      });
    };
  }

  'gt gte lt lte ne in nin regex size maxDistance minDistance'.split(' ').forEach(function(type) {
    describe(type, generalCondition(type));
  });

  describe('mod', function() {
    describe('with 1 argument', function() {
      it('requires a previous where()', function() {
        assert.throws(function() {
          mquery().mod([30, 10]);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('madmen').mod([10, 20]);
        assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
      });
    });

    describe('with 2 arguments and second is non-Array', function() {
      it('requires a previous where()', function() {
        assert.throws(function() {
          mquery().mod('x', 10);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('madmen').mod(10, 20);
        assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
      });
    });

    it('with 2 arguments and second is an array', function() {
      const m = mquery().mod('madmen', [10, 20]);
      assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
    });

    it('with 3 arguments', function() {
      const m = mquery().mod('madmen', 10, 20);
      assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
    });

    it('is chainable', function() {
      const m = mquery().mod('madmen', 10, 20).where('x', 8);
      const check = { madmen: { $mod: [10, 20] }, x: 8 };
      assert.deepEqual(m._conditions, check);
    });
  });

  describe('exists', function() {
    it('with 0 args', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().exists();
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('name').exists();
        const check = { name: { $exists: true } };
        assert.deepEqual(m._conditions, check);
      });
    });

    describe('with 1 arg', function() {
      describe('that is boolean', function() {
        it('throws if not used after where()', function() {
          assert.throws(function() {
            mquery().exists();
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().exists('name', false);
          const check = { name: { $exists: false } };
          assert.deepEqual(m._conditions, check);
        });
      });
      describe('that is not boolean', function() {
        it('sets the value to `true`', function() {
          const m = mquery().where('name').exists('yummy');
          const check = { yummy: { $exists: true } };
          assert.deepEqual(m._conditions, check);
        });
      });
    });

    describe('with 2 args', function() {
      it('works', function() {
        const m = mquery().exists('yummy', false);
        const check = { yummy: { $exists: false } };
        assert.deepEqual(m._conditions, check);
      });
    });

    it('is chainable', function() {
      const m = mquery().where('name').exists().find({ x: 1 });
      const check = { name: { $exists: true }, x: 1 };
      assert.deepEqual(m._conditions, check);
    });
  });

  describe('elemMatch', function() {
    describe('with null/undefined first argument', function() {
      assert.throws(function() {
        mquery().elemMatch();
      }, /Invalid argument/);
      assert.throws(function() {
        mquery().elemMatch(null);
      }, /Invalid argument/);
      assert.doesNotThrow(function() {
        mquery().elemMatch('', {});
      });
    });

    describe('with 1 argument', function() {
      it('throws if not a function or object', function() {
        assert.throws(function() {
          mquery().elemMatch([]);
        }, /Invalid argument/);
      });

      describe('that is an object', function() {
        it('throws if no previous `where` was used', function() {
          assert.throws(function() {
            mquery().elemMatch({});
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().where('comment').elemMatch({ author: 'joe', votes: { $gte: 3 } });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      describe('that is a function', function() {
        it('throws if no previous `where` was used', function() {
          assert.throws(function() {
            mquery().elemMatch(function() {});
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().where('comment').elemMatch(function(query) {
            query.where({ author: 'joe', votes: { $gte: 3 } });
          });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
    });

    describe('with 2 arguments', function() {
      describe('and the 2nd is an object', function() {
        it('works', function() {
          const m = mquery().elemMatch('comment', { author: 'joe', votes: { $gte: 3 } });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      describe('and the 2nd is a function', function() {
        it('works', function() {
          const m = mquery().elemMatch('comment', function(query) {
            query.where({ author: 'joe', votes: { $gte: 3 } });
          });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      it('and the 2nd is not a function or object', function() {
        assert.throws(function() {
          mquery().elemMatch('comment', []);
        }, /Invalid argument/);
      });
    });
  });

  describe('within', function() {
    it('is chainable', function() {
      const m = mquery();
      assert.equal(m.where('a').within(), m);
    });
    describe('when called with arguments', function() {
      it('must follow where()', function() {
        assert.throws(function() {
          mquery().within([]);
        }, /must be used after where/);
      });

      describe('of length 1', function() {
        it('throws if not a recognized shape', function() {
          assert.throws(function() {
            mquery().where('loc').within({});
          }, /Invalid argument/);
          assert.throws(function() {
            mquery().where('loc').within(null);
          }, /Invalid argument/);
        });
        it('delegates to circle when center exists', function() {
          const m = mquery().where('loc').within({ center: [10, 10], radius: 3 });
          assert.deepEqual({ $geoWithin: { $center: [[10, 10], 3] } }, m._conditions.loc);
        });
        it('delegates to box when exists', function() {
          const m = mquery().where('loc').within({ box: [[10, 10], [11, 14]] });
          assert.deepEqual({ $geoWithin: { $box: [[10, 10], [11, 14]] } }, m._conditions.loc);
        });
        it('delegates to polygon when exists', function() {
          const m = mquery().where('loc').within({ polygon: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $geoWithin: { $polygon: [[10, 10], [11, 14], [10, 9]] } }, m._conditions.loc);
        });
        it('delegates to geometry when exists', function() {
          const m = mquery().where('loc').within({ type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $geoWithin: { $geometry: { type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] } } }, m._conditions.loc);
        });
      });

      describe('of length 2', function() {
        it('delegates to box()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5]);
          assert.deepEqual(m._conditions.loc, { $geoWithin: { $box: [[1, 2], [2, 5]] } });
        });
      });

      describe('of length > 2', function() {
        it('delegates to polygon()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5], [2, 4], [1, 3]);
          assert.deepEqual(m._conditions.loc, { $geoWithin: { $polygon: [[1, 2], [2, 5], [2, 4], [1, 3]] } });
        });
      });
    });
  });

  describe('geoWithin', function() {
    before(function() {
      mquery.use$geoWithin = false;
    });
    after(function() {
      mquery.use$geoWithin = true;
    });
    describe('when called with arguments', function() {
      describe('of length 1', function() {
        it('delegates to circle when center exists', function() {
          const m = mquery().where('loc').within({ center: [10, 10], radius: 3 });
          assert.deepEqual({ $within: { $center: [[10, 10], 3] } }, m._conditions.loc);
        });
        it('delegates to box when exists', function() {
          const m = mquery().where('loc').within({ box: [[10, 10], [11, 14]] });
          assert.deepEqual({ $within: { $box: [[10, 10], [11, 14]] } }, m._conditions.loc);
        });
        it('delegates to polygon when exists', function() {
          const m = mquery().where('loc').within({ polygon: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $within: { $polygon: [[10, 10], [11, 14], [10, 9]] } }, m._conditions.loc);
        });
        it('delegates to geometry when exists', function() {
          const m = mquery().where('loc').within({ type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $within: { $geometry: { type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] } } }, m._conditions.loc);
        });
      });

      describe('of length 2', function() {
        it('delegates to box()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5]);
          assert.deepEqual(m._conditions.loc, { $within: { $box: [[1, 2], [2, 5]] } });
        });
      });

      describe('of length > 2', function() {
        it('delegates to polygon()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5], [2, 4], [1, 3]);
          assert.deepEqual(m._conditions.loc, { $within: { $polygon: [[1, 2], [2, 5], [2, 4], [1, 3]] } });
        });
      });
    });
  });

  describe('box', function() {
    describe('with 1 argument', function() {
      it('throws', function() {
        assert.throws(function() {
          mquery().box('sometihng');
        }, /Invalid argument/);
      });
    });
    describe('with > 3 arguments', function() {
      it('throws', function() {
        assert.throws(function() {
          mquery().box(1, 2, 3, 4);
        }, /Invalid argument/);
      });
    });

    describe('with 2 arguments', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().box([], []);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('loc').box([1, 2], [3, 4]);
        assert.deepEqual(m._conditions.loc, { $geoWithin: { $box: [[1, 2], [3, 4]] } });
      });
    });

    describe('with 3 arguments', function() {
      it('works', function() {
        const m = mquery().box('loc', [1, 2], [3, 4]);
        assert.deepEqual(m._conditions.loc, { $geoWithin: { $box: [[1, 2], [3, 4]] } });
      });
    });
  });

  describe('polygon', function() {
    describe('when first argument is not a string', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().polygon({});
        }, /must be used after where/);

        assert.doesNotThrow(function() {
          mquery().where('loc').polygon([1, 2], [2, 3], [3, 6]);
        });
      });

      it('assigns arguments to within polygon condition', function() {
        const m = mquery().where('loc').polygon([1, 2], [2, 3], [3, 6]);
        assert.deepEqual(m._conditions, { loc: { $geoWithin: { $polygon: [[1, 2], [2, 3], [3, 6]] } } });
      });
    });

    describe('when first arg is a string', function() {
      it('assigns remaining arguments to within polygon condition', function() {
        const m = mquery().polygon('loc', [1, 2], [2, 3], [3, 6]);
        assert.deepEqual(m._conditions, { loc: { $geoWithin: { $polygon: [[1, 2], [2, 3], [3, 6]] } } });
      });
    });
  });

  describe('circle', function() {
    describe('with one arg', function() {
      it('must follow where()', function() {
        assert.throws(function() {
          mquery().circle('x');
        }, /must be used after where/);
        assert.doesNotThrow(function() {
          mquery().where('loc').circle({ center: [0, 0], radius: 3 });
        });
      });
      it('works', function() {
        const m = mquery().where('loc').circle({ center: [0, 0], radius: 3 });
        assert.deepEqual(m._conditions, { loc: { $geoWithin: { $center: [[0, 0], 3] } } });
      });
    });
    describe('with 3 args', function() {
      it('throws', function() {
        assert.throws(function() {
          mquery().where('loc').circle(1, 2, 3);
        }, /Invalid argument/);
      });
    });
    describe('requires radius and center', function() {
      assert.throws(function() {
        mquery().circle('loc', { center: 1 });
      }, /center and radius are required/);
      assert.throws(function() {
        mquery().circle('loc', { radius: 1 });
      }, /center and radius are required/);
      assert.doesNotThrow(function() {
        mquery().circle('loc', { center: [1, 2], radius: 1 });
      });
    });
  });

  describe('geometry', function() {
    // within + intersects
    const point = { type: 'Point', coordinates: [[0, 0], [1, 1]] };

    it('must be called after within or intersects', function(done) {
      assert.throws(function() {
        mquery().where('a').geometry(point);
      }, /must come after/);

      assert.doesNotThrow(function() {
        mquery().where('a').within().geometry(point);
      });

      assert.doesNotThrow(function() {
        mquery().where('a').intersects().geometry(point);
      });

      done();
    });

    describe('when called with one argument', function() {
      describe('after within()', function() {
        it('and arg quacks like geoJSON', function(done) {
          const m = mquery().where('a').within().geometry(point);
          assert.deepEqual({ a: { $geoWithin: { $geometry: point } } }, m._conditions);
          done();
        });
      });

      describe('after intersects()', function() {
        it('and arg quacks like geoJSON', function(done) {
          const m = mquery().where('a').intersects().geometry(point);
          assert.deepEqual({ a: { $geoIntersects: { $geometry: point } } }, m._conditions);
          done();
        });
      });

      it('and arg does not quack like geoJSON', function(done) {
        assert.throws(function() {
          mquery().where('b').within().geometry({ type: 1, coordinates: 2 });
        }, /Invalid argument/);
        done();
      });
    });

    describe('when called with zero arguments', function() {
      it('throws', function(done) {
        assert.throws(function() {
          mquery().where('a').within().geometry();
        }, /Invalid argument/);

        done();
      });
    });

    describe('when called with more than one arguments', function() {
      it('throws', function(done) {
        assert.throws(function() {
          mquery().where('a').within().geometry({ type: 'a', coordinates: [] }, 2);
        }, /Invalid argument/);
        done();
      });
    });
  });

  describe('intersects', function() {
    it('must be used after where()', function(done) {
      const m = mquery();
      assert.throws(function() {
        m.intersects();
      }, /must be used after where/);
      done();
    });

    it('sets geo comparison to "$intersects"', function(done) {
      const n = mquery().where('a').intersects();
      assert.equal('$geoIntersects', n._geoComparison);
      done();
    });

    it('is chainable', function() {
      const m = mquery();
      assert.equal(m.where('a').intersects(), m);
    });

    it('calls geometry if argument quacks like geojson', function(done) {
      const m = mquery();
      const o = { type: 'LineString', coordinates: [[0, 1], [3, 40]] };
      let ran = false;

      m.geometry = function(arg) {
        ran = true;
        assert.deepEqual(o, arg);
      };

      m.where('a').intersects(o);
      assert.ok(ran);

      done();
    });

    it('throws if argument is not geometry-like', function(done) {
      const m = mquery().where('a');

      assert.throws(function() {
        m.intersects(null);
      }, /Invalid argument/);

      assert.throws(function() {
        m.intersects(undefined);
      }, /Invalid argument/);

      assert.throws(function() {
        m.intersects(false);
      }, /Invalid argument/);

      assert.throws(function() {
        m.intersects({});
      }, /Invalid argument/);

      assert.throws(function() {
        m.intersects([]);
      }, /Invalid argument/);

      assert.throws(function() {
        m.intersects(function() {});
      }, /Invalid argument/);

      assert.throws(function() {
        m.intersects(NaN);
      }, /Invalid argument/);

      done();
    });
  });

  describe('near', function() {
    // near nearSphere
    describe('with 0 args', function() {
      it('is compatible with geometry()', function(done) {
        const q = mquery().where('x').near().geometry({ type: 'Point', coordinates: [180, 11] });
        assert.deepEqual({ $near: { $geometry: { type: 'Point', coordinates: [180, 11] } } }, q._conditions.x);
        done();
      });
    });

    describe('with 1 arg', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().near(1);
        }, /must be used after where/);
      });
      it('does not throw if used after where()', function() {
        assert.doesNotThrow(function() {
          mquery().where('loc').near({ center: [1, 1] });
        });
      });
    });
    describe('with > 2 args', function() {
      it('throws', function() {
        assert.throws(function() {
          mquery().near(1, 2, 3);
        }, /Invalid argument/);
      });
    });

    it('creates $geometry args for GeoJSON', function() {
      const m = mquery().where('loc').near({ center: { type: 'Point', coordinates: [10, 10] } });
      assert.deepEqual({ $near: { $geometry: { type: 'Point', coordinates: [10, 10] } } }, m._conditions.loc);
    });

    it('expects `center`', function() {
      assert.throws(function() {
        mquery().near('loc', { maxDistance: 3 });
      }, /center is required/);
      assert.doesNotThrow(function() {
        mquery().near('loc', { center: [3, 4] });
      });
    });

    it('accepts spherical conditions', function() {
      const m = mquery().where('loc').near({ center: [1, 2], spherical: true });
      assert.deepEqual(m._conditions, { loc: { $nearSphere: [1, 2] } });
    });

    it('is non-spherical by default', function() {
      const m = mquery().where('loc').near({ center: [1, 2] });
      assert.deepEqual(m._conditions, { loc: { $near: [1, 2] } });
    });

    it('supports maxDistance', function() {
      const m = mquery().where('loc').near({ center: [1, 2], maxDistance: 4 });
      assert.deepEqual(m._conditions, { loc: { $near: [1, 2], $maxDistance: 4 } });
    });

    it('supports minDistance', function() {
      const m = mquery().where('loc').near({ center: [1, 2], minDistance: 4 });
      assert.deepEqual(m._conditions, { loc: { $near: [1, 2], $minDistance: 4 } });
    });

    it('is chainable', function() {
      const m = mquery().where('loc').near({ center: [1, 2], maxDistance: 4 }).find({ x: 1 });
      assert.deepEqual(m._conditions, { loc: { $near: [1, 2], $maxDistance: 4 }, x: 1 });
    });

    describe('supports passing GeoJSON, gh-13', function() {
      it('with center', function() {
        const m = mquery().where('loc').near({
          center: { type: 'Point', coordinates: [1, 1] },
          maxDistance: 2
        });

        const expect = {
          loc: {
            $near: {
              $geometry: {
                type: 'Point',
                coordinates: [1, 1]
              },
              $maxDistance: 2
            }
          }
        };

        assert.deepEqual(m._conditions, expect);
      });
    });
  });

  // fields

  describe('select', function() {
    describe('with 0 args', function() {
      it('is chainable', function() {
        const m = mquery();
        assert.equal(m, m.select());
      });
    });

    it('accepts an object', function() {
      const o = { x: 1, y: 1 };
      const m = mquery().select(o);
      assert.deepEqual(m._fields, o);
    });

    it('accepts a string', function() {
      const o = 'x -y';
      const m = mquery().select(o);
      assert.deepEqual(m._fields, { x: 1, y: 0 });
    });

    it('does accept an array', function() {
      const o = ['x', '-y'];
      const m = mquery().select(o);
      assert.deepEqual(m._fields, { x: 1, y: 0 });
    });

    it('merges previous arguments', function() {
      const o = { x: 1, y: 0, a: 1 };
      const m = mquery().select(o);
      m.select('z -u w').select({ x: 0 });
      assert.deepEqual(m._fields, {
        x: 0,
        y: 0,
        z: 1,
        u: 0,
        w: 1,
        a: 1
      });
    });

    it('rejects non-string, object, arrays', function() {
      assert.throws(function() {
        mquery().select(function() {});
      }, /Invalid select\(\) argument/);
    